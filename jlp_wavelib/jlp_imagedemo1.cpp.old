//============================================================================
// Name        : jlp_imagedemo1.cpp
// Author      : JLP 
// Version     : From imagedemo1.cpp by Raffat Hussain
// Copyright   : 
// Description : DWT of arbitrary size image using symmetric or periodic extension
//============================================================================

#include <stdlib.h> // exit()

#include <vector>
#include <string>

#include "wavelet2s.h"
#include "jlp_fitsio.h"         // for JLP_RDFITS_2D

#include "jlp_wavelib_utils.h"

//
int jlp_LoadFITSImage(char *filename1, double **dble_image1, 
                      int *nx1, int *ny1, char *comments1, char *errmess1);
int jlp_image_to_vector(double *dble_image1, int nx1, int ny1,
                        vector<vector<double> > &vec1);
int jlp_dwt_transform(vector<vector<double> > &vec1, int nx1, int ny1,
                      double **dble_image2, int *nx2, int *ny2,
                      double **dble_image3, int *nx3, int *ny3);
int jlp_idwt_reconstructed( vector<double> output0, vector<double> flag0, 
                            vector<int> length0, string nm0, int nx1, int ny1,
                            double **dble_image3, int *nx3, int *ny3);
void* maxval_2d(vector<vector<double> > &arr, double &max);
void* maxval_1d(vector<double> &arr, double &max);

/***********************************************************************
*
*************************************************************************/
int main(int argc, char* argv[]) {
char filename1[120], comments1[80], errmess1[200];
double *dble_image1, *dble_image2, *dble_image3;
int nx1, ny1, nx2, ny2, nx3, ny3;

strcpy(filename1, "lena512.fits");
jlp_LoadFITSImage(filename1, &dble_image1, &nx1, &ny1, comments1, errmess1);

vector<vector<double> > vec1(nx1, vector<double>(ny1));
jlp_image_to_vector(dble_image1, nx1, ny1, vec1);

jlp_dwt_transform(vec1, nx1, ny1, &dble_image2, &nx2, &ny2,
                  &dble_image3, &nx3, &ny3);

strcpy(filename1, "lena512_dwt.fits");
strcpy(comments1, "DWT transform of lena512.fits");
printf("Output dwt image: nx2=%d ny2=%d\n", nx2, ny2);
JLP_WRFITS_2D_dble(dble_image2, nx2, ny2, nx2, filename1, comments1, errmess1);

strcpy(filename1, "lena512_recon.fits");
strcpy(comments1, "Reconsruction from DWT transform of lena512.fits");
printf("Output reconstructed image: nx3=%d ny3=%d\n", nx3, ny3);
JLP_WRFITS_2D_dble(dble_image3, nx3, ny3, nx3, filename1, comments1, errmess1);

return(0);
}

/******************************************************************
* Determining the maximum value of 2D vector
******************************************************************/
void* maxval_2d(vector<vector<double> > &arr, double &max){
    max = 0;
    for (unsigned int i =0; i < arr.size(); i++) {
        for (unsigned int j =0; j < arr[0].size(); j++) {
            if (max <= arr[i][j]){
                max = arr[i][j];
            }
        }
    }
    return 0;
}

/******************************************************************
* Load an image in a 2DFITS file or a single plane in 3D FITS cube
*
*******************************************************************/
int jlp_LoadFITSImage(char *filename1, double **dble_image1, 
                      int *nx1, int *ny1, char *comments1, char *errmess1)
{
int nz0;
int status, iframe = 1;

// dble_image1: array with the data contained in FITS file
// nx1, ny1, nz0: size of data cube
// iframe: index of image plane to be loaded from 1 to nz (in case of 3D data)

status = JLP_RDFITS_2D_dble(dble_image1, nx1, ny1, &nz0, iframe, filename1,
                             comments1, errmess1);
if (status) {
  fprintf(stderr, "Error loading image from %s (status=%d)\n %s\n",
          filename1, status, errmess1);
  return(-2);
  }

return(0);
}

/******************************************************************
* Determining the maximum value of 1D vector
******************************************************************/
void* maxval_1d(vector<double> &arr, double &max){
    max = 0;
    for (unsigned int i =0; i < arr.size(); i++) {
        if (max <= arr[i]){
            max = arr[i];
        }

    }
    return 0;
}

/******************************************************************
* Convert an image to a 2D vector 
*******************************************************************/
int jlp_image_to_vector(double *dble_image1, int nx1, int ny1,
                        vector<vector<double> > &vec1) 
{
int i, j, k;

// vector<vector<double> > vec1(nx1, vector<double>(ny1));

 k = 0;
 for(i = 0; i < nx1; i++) {
   for(j = 0; j < ny1; j++){
         vec1[i][j] = dble_image1[k];
         k++;
     }
   }

return(0);
}

/************************************************************************
*
************************************************************************/
int jlp_dwt_transform(vector<vector<double> > &vec1, int nx1, int ny1,
                      double **dble_image2, int *nx2, int *ny2,
                      double **dble_image3, int *nx3, int *ny3)
{
 string nm0 = "db3";
 vector<double> l1,h1,l2,h2;
 vector<int> length2;
 filtcoef(nm0, l1, h1, l2, h2);
 int size_n, rows_n, cols_n;

// Finding 2D DWT Transform of the image using symetric extension algorithm
// Extension is set to 3 (eg., int e = 3)

 vector<int> length0;
 vector<double> output0, flag0;
 int J0 = 3;

// dwt, discrete wavelet transform:
  dwt_2d_sym(vec1, J0, nm0, output0, flag0, length0);

/* This algorithm computes DWT of image of any given size. 
* Together with convolution and subsampling operations it is clear 
* that subsampled images are of different length than dyadic length images. 
* In order to compute the "effective" size of DWT we do additional calculations.
*/
  dwt_output_dim_sym(length0, length2, J0);

/* length2 is gives the integer vector that contains the size of subimages 
* that will combine to form the displayed output image. 
* The last two entries of length2 gives the size of DWT ( rows_n by cols_n)
*/
  size_n = length2.size();
  rows_n=length2[size_n - 2];
  cols_n = length2[size_n -1];

  vector<vector< double> > dwt_disp1(rows_n, vector<double>(cols_n));

/* The dispDWT function returns the 2D object dwt_disp1 which will be displayed 
* using OPENCV's image handling functions
*/
  dispDWT(output0, dwt_disp1, length0 ,length2, J0);

 *nx2 = rows_n;
 *ny2 = cols_n;
 *dble_image2 = new double[rows_n * cols_n];
 for(int i = 0; i < rows_n; i++){
    for (int j = 0; j < cols_n; j++){
     (*dble_image2)[ i + j * rows_n] = dwt_disp1[i][j];
    }
 }

jlp_idwt_reconstructed(output0, flag0, length0, nm0, nx1, ny1,
                       dble_image3, nx3, ny3);

return(0);
}
/*************************************************************************
* Inverse discrete wavelength transform
*
**************************************************************************/
int jlp_idwt_reconstructed( vector<double> output0, vector<double> flag0, 
                            vector<int> length0, string nm0, int nx1, int ny1,
                            double **dble_image3, int *nx3, int *ny3)
{

// Finding IDWT
vector<vector<double> > idwt_output3(nx1, vector<double>(ny1));

 idwt_2d_sym(output0, flag0, nm0, idwt_output3, length0);
 *nx3 = idwt_output3[0].size();
 *ny3 = idwt_output3[1].size();
  printf(" nx3=%d ny3=%d\n", *nx3, *ny3);
 *dble_image3 = new double[(*nx3) * (*ny3)];
 for(int i = 0; i < (*nx3); i++){
    for (int j = 0; j < (*ny3); j++){
     (*dble_image3)[ i + j * (*nx3)] = idwt_output3[i][j];
    }
 }

return(0);
}
